diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index 4bcd3ce..a00dd61 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -671,6 +671,7 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
     glamor_ctx->make_current = glamor_egl_make_current;
 
 #ifdef DRI3
+    xf86Msg(X_INFO, "DRI3 capable: %d\n", glamor_egl->dri3_capable);
     if (glamor_egl->dri3_capable) {
     	glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
         /* Tell the core that we have the interfaces for import/export
@@ -687,7 +688,9 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
             /* To do DRI3 device FD generation, we need to open a new fd
              * to the same device we were handed in originally.
              */
-            glamor_egl->device_path = drmGetDeviceNameFromFd(glamor_egl->fd);
+            //glamor_egl->device_path = drmGetDeviceNameFromFd(glamor_egl->fd);
+            glamor_egl->device_path = "/dev/dri/renderD128";
+	    xf86Msg(X_INFO, "DRI3 device name: %s %d\n", glamor_egl->device_path, glamor_egl->fd);
 
             if (!dri3_screen_init(screen, &glamor_dri3_info)) {
                 xf86DrvMsg(scrn->scrnIndex, X_ERROR,
@@ -756,6 +759,11 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
         xf86GlamorEGLPrivateIndex = xf86AllocateScrnInfoPrivateIndex();
 
     scrn->privates[xf86GlamorEGLPrivateIndex].ptr = glamor_egl;
+
+
+    fd = open("/dev/dri/renderD128", O_RDWR);
+    xf86Msg(X_INFO, "Opening render node: %d\n", fd);
+
     glamor_egl->fd = fd;
 #ifdef GLAMOR_HAS_GBM
     glamor_egl->gbm = gbm_create_device(glamor_egl->fd);
diff --git a/hw/xfree86/dri2/dri2.c b/hw/xfree86/dri2/dri2.c
index d55be19..00c5c61 100644
--- a/hw/xfree86/dri2/dri2.c
+++ b/hw/xfree86/dri2/dri2.c
@@ -1334,9 +1334,12 @@ DRI2Connect(ClientPtr client, ScreenPtr pScreen,
         return FALSE;
 
     *driverName = ds->driverNames[driver_id];
-    *deviceName = ds->deviceName;
+    //*deviceName = ds->deviceName;
+    *deviceName = "/dev/dri/renderD128";
     *fd = ds->fd;
 
+    xf86Msg(X_INFO, "%s: %s %s %d\n", __func__, *driverName, *deviceName, *fd);
+
     if (client) {
         DRI2ClientPtr dri2_client;
         dri2_client = dri2ClientPrivate(client);
diff --git a/hw/xfree86/drivers/modesetting/dri2.c b/hw/xfree86/drivers/modesetting/dri2.c
index 83cb3e0..3834a01 100644
--- a/hw/xfree86/drivers/modesetting/dri2.c
+++ b/hw/xfree86/drivers/modesetting/dri2.c
@@ -831,9 +831,10 @@ ms_dri2_screen_init(ScreenPtr screen)
     }
 
     memset(&info, '\0', sizeof(info));
-    info.fd = ms->fd;
+    info.fd = gbm_device_get_fd(ms->drmmode.gbm);
+    //info.fd = ms->fd;
     info.driverName = NULL; /* Compat field, unused. */
-    info.deviceName = drmGetDeviceNameFromFd(ms->fd);
+    info.deviceName = drmGetDeviceNameFromFd(info.fd);
 
     info.version = 4;
     info.CreateBuffer = ms_dri2_create_buffer;
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.c b/hw/xfree86/drivers/modesetting/drmmode_display.c
index 262e015..f573a27 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.c
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.c
@@ -50,6 +50,8 @@
 
 #include "driver.h"
 
+#include <tegra_drm.h>
+
 static Bool drmmode_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height);
 
 static Bool
@@ -160,15 +162,61 @@ drmmode_bo_map(drmmode_ptr drmmode, drmmode_bo *bo)
 }
 
 static Bool
+drmmode_tegra_import(drmmode_ptr drmmode, drmmode_bo *bo)
+{
+	struct drm_tegra_gem_set_tiling args;
+	int err;
+
+	memset(&args, 0, sizeof(args));
+	args.handle = bo->drm_handle;
+	args.mode = DRM_TEGRA_GEM_TILING_MODE_BLOCK;
+	args.value = 4;
+
+	err = ioctl(drmmode->fd, DRM_IOCTL_TEGRA_GEM_SET_TILING, &args);
+	if (err < 0) {
+		xf86Msg(X_ERROR, "failed to set tiling parameters\n");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static Bool
 drmmode_create_bo(drmmode_ptr drmmode, drmmode_bo *bo,
                   unsigned width, unsigned height, unsigned bpp)
 {
 #ifdef GLAMOR_HAS_GBM
+    uint32_t handle;
+    int fd;
+    int ret;
+
     if (drmmode->glamor) {
         bo->gbm = gbm_bo_create(drmmode->gbm, width, height,
                                 GBM_FORMAT_ARGB8888,
                                 GBM_BO_USE_RENDERING | GBM_BO_USE_SCANOUT);
-        return bo->gbm != NULL;
+
+	if (bo->gbm == NULL)
+		return FALSE;
+
+	handle = gbm_bo_get_handle(bo->gbm).u32;
+
+	ret = drmPrimeHandleToFD(gbm_device_get_fd(drmmode->gbm), handle, 0, &fd);
+	if (ret) {
+		xf86Msg(X_ERROR, "failed to export bo\n");
+		return FALSE;
+	}
+
+	ret = drmPrimeFDToHandle(drmmode->fd, fd, &handle);
+	if (ret) {
+		xf86Msg(X_ERROR, "failed to import bo\n");
+		close(fd);
+		return FALSE;
+	}
+
+	close(fd);
+	bo->drm_handle = handle;
+
+	return drmmode_tegra_import(drmmode, bo);
     }
 #endif
 
@@ -688,7 +736,7 @@ drmmode_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
     ret = drmModeAddFB(drmmode->fd, width, height, crtc->scrn->depth,
                        crtc->scrn->bitsPerPixel,
                        drmmode_bo_get_pitch(&drmmode_crtc->rotate_bo),
-                       drmmode_bo_get_handle(&drmmode_crtc->rotate_bo),
+                       drmmode_crtc->rotate_bo.drm_handle,
                        &drmmode_crtc->rotate_fb_id);
 
     if (ret) {
@@ -1669,7 +1717,7 @@ drmmode_xf86crtc_resize(ScrnInfoPtr scrn, int width, int height)
 
     ret = drmModeAddFB(drmmode->fd, width, height, scrn->depth,
                        scrn->bitsPerPixel, pitch,
-                       drmmode_bo_get_handle(&drmmode->front_bo),
+                       drmmode->front_bo.drm_handle,
                        &drmmode->fb_id);
     if (ret)
         goto fail;
diff --git a/hw/xfree86/drivers/modesetting/drmmode_display.h b/hw/xfree86/drivers/modesetting/drmmode_display.h
index fca68a6..4c0ea8b 100644
--- a/hw/xfree86/drivers/modesetting/drmmode_display.h
+++ b/hw/xfree86/drivers/modesetting/drmmode_display.h
@@ -41,6 +41,7 @@ typedef struct {
 #ifdef GLAMOR_HAS_GBM
     struct gbm_bo *gbm;
 #endif
+    uint32_t drm_handle;
 } drmmode_bo;
 
 typedef struct {
